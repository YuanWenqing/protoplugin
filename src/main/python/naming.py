#!/usr/bin/python

import sys, os
import itertools

from google.protobuf.compiler import plugin_pb2 as plugin
from google.protobuf.descriptor_pb2 import DescriptorProto


def index_proto(proto_files):
  n2f = dict()
  for proto_file in proto_files:
    n2f[proto_file.name] = proto_file

  return n2f

def findMsgComment(locations, msgIdx):
  return findComment(locations, [4, msgIdx])


def findFieldComment(locations, msgIdx, fieldIdx):
  return findComment(locations, [4, msgIdx, 2, fieldIdx])


def findComment(locations, path):
  finds = findLocation(locations, path)
  s = ''
  for l in finds:
    s += l.leading_comments or ''
    s += l.trailing_comments or ''
  return s


def findLocation(locations, path):
  '''
  path: path of comment, see https://github.com/google/protobuf/blob/master/src/google/protobuf/descriptor.proto
  examples paths:
  [4, m] - message comments, m: msgIdx in proto from 0
  [4, m, 2, f] - field comments in message, f: fieldIdx in message from 0
  [6, s] - service comments, s: svcIdx in proto from 0
  [6, s, 2, r] - rpc comments in service, r: rpc method def in service from 0
  '''
  finds = []
  for l in locations:
    if l.path != path:
      continue
    finds.append(l)
  return finds


def samePath(p1, p2):
  return p1 == p2


def formatComment(comments, padding):
  if not comments or len(comments) == 0:
    return ''
  formatted = ''
  for line in comments.split('\n'):
    line = line.strip()
    if line != '':
      formatted += padding + line + '\n'
  formatted += padding + '<p>\n'
  return formatted


class TypeWrapper:
  def __init__(self, proto_file, descriptor, typename):
    self.proto_file = proto_file
    self.descriptor = descriptor
    if not typename.startswith('.'):
      typename = '.' + typename
    self.typename = typename

  def isEnum(self):
    return isinstance(self.typeDescriptor, DescriptorProto)

  def isMap(self):
    return self.typeDescriptor.options.map_entry

def traverse(proto_file):
  def _traverse(pkg, items):
    for item in items:
      yield pkg, item
      if isinstance(item, DescriptorProto):
        nestPkg = pkg + '.' + item.name
        for enum in item.enum_type:
          yield nestPkg, enum
        for msg in item.nested_type:
          yield nestPkg, msg
  return itertools.chain(
    _traverse(proto_file.package, proto_file.enum_type),
    _traverse(proto_file.package, proto_file.message_type),
  )

def index_type(proto_files):
  name2type = dict()
  for proto_file in proto_files:
    for pkg, item in traverse(proto_file):
      typename = pkg + '.' + item.name
      wrapper = TypeWrapper(proto_file, item, typename)
      name2type[wrapper.typename] = wrapper
  return name2type

class NamingFormatter:
  FileTemplate = '''/* Generated by the proto-naming plugin.  DO NOT EDIT! */

package %s;

/**
 * file: %s
 */
public interface %s {
%s
}
'''
  MsgTemplate = '''
  /**
%s   * proto: %s
   */%s
  interface %sNaming {
%s
  }
'''
  FieldTemplate = '    String %s = "%s";\n'

  def __init__(self, proto):
    self.proto = proto
    self.javaPkg = '%s.naming' % proto.options.java_package
    self.javaOuterCls = proto.options.java_outer_classname + 'Naming'

  def generate_code(self):
    code = ''
    for msgIdx in range(len(self.proto.message_type)):
      code += self.generate_msg(msgIdx)
    return NamingFormatter.FileTemplate % (self.javaPkg, self.proto.name, self.javaOuterCls, code)

  def generate_msg(self, msgIdx):
    msg = self.proto.message_type[msgIdx]
    fullName = self.proto.package + '.' + msg.name
    annotation = ''
    if msg.options.deprecated:
      annotation = '\n  @java.lang.Deprecated'
    fieldCode = ''
    for fieldIdx in range(len(msg.field)):
      fieldCode += self.generate_field(msgIdx, fieldIdx)
    comment = findMsgComment(self.proto.source_code_info.location, msgIdx)
    comment = formatComment(comment, '   * ')
    return NamingFormatter.MsgTemplate % (comment, fullName, annotation, msg.name, fieldCode)

  def generate_field(self, msgIdx, fieldIdx):
    msg = self.proto.message_type[msgIdx]
    field = msg.field[fieldIdx]
    code = ''
    if field.options.deprecated:
      code = '    @java.lang.Deprecated\n'
    code += NamingFormatter.FieldTemplate % (field.name.upper(), field.name)
    comment = findFieldComment(self.proto.source_code_info.location, msgIdx, fieldIdx)
    comment = formatComment(comment, '     * ')
    if comment != '':
      comment = '    /**\n%s     */\n' % comment
      code = comment + code
    return code


def generate_code(request, response):
  n2f = index_proto(request.proto_file)

  for filename in request.file_to_generate:
    proto = n2f[filename]
    if len(proto.message_type) == 0:
      continue

    formatter = NamingFormatter(proto)
    outf = response.file.add()
    path = formatter.javaPkg.replace('.', os.path.sep)
    fn = formatter.javaOuterCls + '.java'
    outf.name = os.path.join(path, fn)
    outf.content = formatter.generate_code()


if __name__ == '__main__':
  # Read request message from stdin
  data = sys.stdin.read()

  # Parse request
  request = plugin.CodeGeneratorRequest()
  request.ParseFromString(data)

  # Create response
  response = plugin.CodeGeneratorResponse()

  # Generate code
  generate_code(request, response)

  # Serialise response message
  output = response.SerializeToString()

  # Write to stdout
  sys.stdout.write(output)
