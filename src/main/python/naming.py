#!/usr/bin/python

import sys
import os
import itertools

from google.protobuf.compiler import plugin_pb2 as plugin
from google.protobuf.descriptor_pb2 import DescriptorProto


def index_proto(proto_files):
    n2f = dict()
    for proto_file in proto_files:
        n2f[proto_file.name] = proto_file

    return n2f


def find_msg_comment(locations, msg_idx):
    return find_comment(locations, [4, msg_idx])


def find_field_comment(locations, msg_idx, field_idx):
    return find_comment(locations, [4, msg_idx, 2, field_idx])


def find_comment(locations, path):
    finds = find_location(locations, path)
    s = ''
    for l in finds:
        s += l.leading_comments or ''
        s += l.trailing_comments or ''
    return s


def find_location(locations, path):
    """
    path: path of comment, see https://github.com/google/protobuf/blob/master/src/google/protobuf/descriptor.proto
    examples paths:
    [4, m] - message comments, m: msgIdx in proto from 0
    [4, m, 2, f] - field comments in message, f: fieldIdx in message from 0
    [6, s] - service comments, s: svcIdx in proto from 0
    [6, s, 2, r] - rpc comments in service, r: rpc method def in service from 0
    """
    finds = []
    for l in locations:
        if l.path != path:
            continue
        finds.append(l)
    return finds


def format_comment(comments, padding):
    if not comments or len(comments) == 0:
        return ''
    formatted = ''
    for line in comments.split('\n'):
        line = line.strip()
        if line != '':
            formatted += padding + line + '\n'
    formatted += padding + '<p>\n'
    return formatted


class TypeWrapper:
    def __init__(self, proto_file, descriptor, typename):
        self.proto_file = proto_file
        self.descriptor = descriptor
        if not typename.startswith('.'):
            typename = '.' + typename
        self.typename = typename

    def is_enum(self):
        return isinstance(self.descriptor, DescriptorProto)

    def is_map(self):
        return self.descriptor.options.map_entry


def traverse(proto_file):
    def _traverse(pkg, items):
        for item in items:
            yield pkg, item
            if isinstance(item, DescriptorProto):
                nest_pkg = pkg + '.' + item.name
                for enum in item.enum_type:
                    yield nest_pkg, enum
                for msg in item.nested_type:
                    yield nest_pkg, msg

    return itertools.chain(
        _traverse(proto_file.package, proto_file.enum_type),
        _traverse(proto_file.package, proto_file.message_type),
    )


def index_type(proto_files):
    name2type = dict()
    for proto_file in proto_files:
        for pkg, item in traverse(proto_file):
            typename = pkg + '.' + item.name
            wrapper = TypeWrapper(proto_file, item, typename)
            name2type[wrapper.typename] = wrapper
    return name2type


class NamingFormatter:
    FileTemplate = """/* Generated by the proto-naming plugin.  DO NOT EDIT! */

package %s;

/**
 * file: %s
 */
public interface %s {
%s
}
"""
    MsgTemplate = """
  /**
%s   * proto: %s
   */%s
  interface %sNaming {
%s
  }
"""
    FieldTemplate = '    String %s = "%s";\n'

    def __init__(self, proto):
        self.proto = proto
        self.javaPkg = '%s.naming' % proto.options.java_package
        self.javaOuterCls = proto.options.java_outer_classname + 'Naming'

    def generate_code(self):
        code = ''
        for msgIdx in range(len(self.proto.message_type)):
            code += self.generate_msg(msgIdx)
        return NamingFormatter.FileTemplate % (self.javaPkg, self.proto.name, self.javaOuterCls, code)

    def generate_msg(self, msg_idx):
        msg = self.proto.message_type[msg_idx]
        full_name = self.proto.package + '.' + msg.name
        annotation = ''
        if msg.options.deprecated:
            annotation = '\n  @java.lang.Deprecated'
        field_code = ''
        for fieldIdx in range(len(msg.field)):
            field_code += self.generate_field(msg_idx, fieldIdx)
        comment = find_msg_comment(self.proto.source_code_info.location, msg_idx)
        comment = format_comment(comment, '   * ')
        return NamingFormatter.MsgTemplate % (comment, full_name, annotation, msg.name, field_code)

    def generate_field(self, msg_idx, field_idx):
        msg = self.proto.message_type[msg_idx]
        field = msg.field[field_idx]
        code = ''
        if field.options.deprecated:
            code = '    @java.lang.Deprecated\n'
        code += NamingFormatter.FieldTemplate % (field.name.upper(), field.name)
        comment = find_field_comment(self.proto.source_code_info.location, msg_idx, field_idx)
        comment = format_comment(comment, '     * ')
        if comment != '':
            comment = '    /**\n%s     */\n' % comment
            code = comment + code
        return code


def generate_code(req, resp):
    n2f = index_proto(req.proto_file)

    for filename in req.file_to_generate:
        proto = n2f[filename]
        if len(proto.message_type) == 0:
            continue

        formatter = NamingFormatter(proto)
        out_f = resp.file.add()
        path = formatter.javaPkg.replace('.', os.path.sep)
        fn = formatter.javaOuterCls + '.java'
        out_f.name = os.path.join(path, fn)
        out_f.content = formatter.generate_code()


if __name__ == '__main__':
    # Read request message from stdin
    data = sys.stdin.read()

    # Parse request
    request = plugin.CodeGeneratorRequest()
    request.ParseFromString(data)

    # Create response
    response = plugin.CodeGeneratorResponse()

    # Generate code
    generate_code(request, response)

    # Serialise response message
    output = response.SerializeToString()

    # Write to stdout
    sys.stdout.write(output)
